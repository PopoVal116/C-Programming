Реализация и тестирование пузырьковой сортировки
Обзор проекта
Этот проект реализует алгоритм пузырьковой сортировки на языке C, а также функции для создания массивов с определёнными шаблонами (возрастающий, убывающий и случайный порядок). Включает набор тестов с использованием фреймворка CMocka для проверки корректности работы кода. Проект собирается с помощью CMake, что упрощает компиляцию и запуск тестов. Код написан просто, понятно и хорошо задокументирован, чтобы его было легко изучить и поддерживать.
Основные цели проекта:

Реализовать пузырьковую сортировку с подсчётом сравнений и перемещений.
Создать функции для генерации массивов для тестирования разных случаев.
Написать модульные тесты для проверки корректности кода.
Использовать CMake для автоматизации сборки и тестирования.

Примечание: Перед публикацией этого кода на GitHub убедитесь, что это соответствует правилам вашей учебной программы. Публикация кода лабораторной работы может нарушать правила академической честности в некоторых университетах.
Теоретическая часть
Что такое пузырьковая сортировка?
Пузырьковая сортировка — это простой алгоритм сортировки, который многократно проходит по списку, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке. Процесс повторяется, пока не потребуется больше обменов, что означает, что список отсортирован. Название «пузырьковая» происходит от того, что меньшие элементы как бы «всплывают» к началу списка.

Как работает:

Начинаем с начала массива.
Сравниваем каждую пару соседних чисел.
Если первое число больше второго, меняем их местами.
Повторяем для каждой пары, затем начинаем сначала.
После каждого прохода наибольшее неотсортированное число оказывается в конце, поэтому проверяем меньше пар в следующем проходе.
Останавливаемся, когда не нужно больше обменов.


Производительность:

Лучший случай: O(n) сравнений, когда массив уже отсортирован (обмены не нужны).
Худший случай: O(n²) сравнений и O(n²) обменов, когда массив отсортирован в обратном порядке.
Средний случай: O(n²) сравнений и обменов.
Пузырьковая сортировка неэффективна для больших данных, но проста для понимания и реализации.


Зачем считать сравнения и перемещения?

Сравнения: Показывают, сколько раз мы проверяли, больше ли одно число другого. Это отражает, сколько работы делает алгоритм для принятия решений об обменах.
Перемещения: Показывают, сколько раз мы перемещали числа при обменах (считаем 3 перемещения на обмен: сохранить одно число, переместить другое, поставить сохранённое). Это помогает измерить усилия алгоритма по перестановке массива.



Зачем модульное тестирование?
Модульное тестирование — это способ проверить, что отдельные части кода (например, функции) работают правильно. Мы используем CMocka для написания тестов, которые:

Проверяют, что bubbleSort правильно сортирует массивы в разных случаях (пустой, с одним элементом, отсортированный, в обратном порядке, случайный, с повторами).
Убеждаются, что функции генерации массивов (make_down_nums, make_up_nums, make_random_nums) дают ожидаемые результаты.
Проверяют правильность подсчёта сравнений и перемещений.

Тестирование помогает находить ошибки на ранних этапах, гарантирует, что код работает как ожидалось, и упрощает внесение изменений без риска сломать программу.
Описание кода
Проект состоит из четырёх файлов:

sort.h: Объявляет функции, используемые в проекте.
sort.c: Реализует пузырьковую сортировку и функции генерации массивов.
test_sort.c: Содержит модульные тесты для проверки кода.
CMakeLists.txt: Настраивает процесс сборки и запуска тестов.

Ниже приведено подробное описание каждого файла, с построчным разбором для sort.c, test_sort.c и CMakeLists.txt.
sort.h
Этот заголовочный файл объявляет функции, чтобы их можно было использовать в других файлах. Он гарантирует, что компилятор знает, какие функции существуют и как их вызывать.
Основное содержимое:

Объявляет bubbleSort для сортировки массива и подсчёта сравнений/перемещений.
Объявляет make_down_nums, make_random_nums и make_up_nums для создания массивов в убывающем, случайном и возрастающем порядке.

Зачем нужен: Он как план, позволяющий sort.c и test_sort.c использовать одни и те же функции без дублирования кода.
sort.c
Этот файл содержит реализацию алгоритма пузырьковой сортировки и функций генерации массивов. Это основа проекта, выполняющая сортировку и создание массивов.
Построчное объяснение:
#include <stdio.h>


Подключает библиотеку для печати (например, printf), хотя здесь не используется. Оставлена на случай отладки.

#include <stdlib.h>


Подключает библиотеку для генерации случайных чисел (rand) и других утилит.

#include "sort.h"


Подключает заголовочный файл sort.h, где объявлены функции, которые мы здесь определяем.

void bubbleSort(int nums[], int count, int *comps, int *moves) {


Определяет функцию bubbleSort. Принимает:
nums[]: Массив для сортировки.
count: Количество элементов в массиве.
comps: Указатель для хранения числа сравнений.
moves: Указатель для хранения числа перемещений.



    *comps = 0;


Устанавливает счётчик сравнений в 0.

    *moves = 0;


Устанавливает счётчик перемещений в 0.

    for (int i = 0; i < count - 1; i++) {


Запускает цикл, который выполняется count - 1 раз. i считает проходы по массиву.

        for (int j = 0; j < count - i - 1; j++) {


Запускает вложенный цикл для проверки пар чисел. Он проверяет меньше пар с каждым проходом, так как большие числа уже на месте.

            (*comps)++;


Увеличивает счётчик сравнений для каждой проверенной пары.

            if (nums[j] > nums[j + 1]) {


Проверяет, больше ли текущее число следующего.

                int temp = nums[j];


Сохраняет текущее число во временной переменной.

                nums[j] = nums[j + 1];


Перемещает следующее число на текущую позицию.

                nums[j + 1] = temp;


Ставит сохранённое число на следующую позицию, завершая обмен.

                (*moves) += 3;


Добавляет 3 к счётчику перемещений (один обмен = 3 перемещения: сохранить, переместить, поставить).

            }
        }
    }
}


Закрывает if, внутренний цикл, внешний цикл и функцию.

void make_down_nums(int nums[], int count) {


Определяет функцию для заполнения массива числами в убывающем порядке (например, 5, 4, 3, 2, 1).

    for (int i = 0; i < count; i++) {


Проходит по массиву от 0 до count - 1.

        nums[i] = count - i;


Устанавливает каждую позицию в count - i (например, для count=5, позиция 0 получает 5, позиция 1 — 4).

    }
}


Закрывает цикл и функцию.

void make_random_nums(int nums[], int count) {


Определяет функцию для заполнения массива случайными числами.

    for (int i = 0; i < count; i++) {


Проходит по массиву.

        nums[i] = rand() % 100;


Устанавливает каждую позицию в случайное число от 0 до 99 с помощью rand().

    }
}


Закрывает цикл и функцию.

void make_up_nums(int nums[], int count) {


Определяет функцию для заполнения массива числами в возрастающем порядке (например, 1, 2, 3, 4, 5).

    for (int i = 0; i < count; i++) {


Проходит по массиву.

        nums[i] = i + 1;


Устанавливает каждую позицию в i + 1 (например, позиция 0 получает 1, позиция 1 — 2).

    }
}


Закрывает цикл и функцию.

test_sort.c
Этот файл содержит модульные тесты с использованием CMocka для проверки работы bubbleSort и функций генерации массивов. Включает подробные комментарии на русском языке для каждой строки.
Построчное объяснение (отражено в комментариях):
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>


Подключает библиотеки, необходимые для внутренней работы CMocka (обработка аргументов, определение размеров, переходы в коде).

#include <cmocka.h>


Подключает библиотеку CMocka для написания и запуска тестов.

#include <stdlib.h>


Подключает библиотеку для генерации случайных чисел (rand).

#include "sort.h"


Подключает sort.h для доступа к функциям bubbleSort и генерации массивов.

// Проверяет, отсортирован ли массив (числа идут по порядку от меньшего к большему)
int is_sorted(int nums[], int count) {
    // Проходим по массиву, но не до конца, чтобы сравнить с следующим числом
    for (int i = 0; i < count - 1; i++) {
        // Если текущее число больше следующего, массив не отсортирован
        if (nums[i] > nums[i + 1]) {
            // Возвращаем 0 (значит "не отсортирован")
            return 0;
        }
    }
    // Если дошли сюда, массив отсортирован, возвращаем 1 (значит "да")
    return 1;
}


Определяет вспомогательную функцию, проверяющую, отсортирован ли массив (каждое число меньше или равно следующему).

// Тест для bubbleSort с пустым массивом
void test_empty(void **state) {
    // Создаем указатель на массив, но он пустой (NULL)
    int *nums = NULL;
    // Создаем счетчики для сравнений и перемещений, ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort с пустым массивом и размером 0
    bubbleSort(nums, 0, &comps, &moves);
    // Проверяем, что сравнений не было (должно быть 0)
    assert_int_equal(comps, 0);
    // Проверяем, что перемещений не было (должно быть 0)
    assert_int_equal(moves, 0);
}


Проверяет, что bubbleSort обрабатывает пустой массив без ошибок, с 0 сравнениями и перемещениями.

// Тест для bubbleSort с массивом из одного числа
void test_one_num(void **state) {
    // Создаем массив с одним числом: 1
    int nums[] = {1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort для массива с одним числом
    bubbleSort(nums, 1, &comps, &moves);
    // Проверяем, что число осталось 1 (не должно измениться)
    assert_int_equal(nums[0], 1);
    // Проверяем, что сравнений не было
    assert_int_equal(comps, 0);
    // Проверяем, что перемещений не было
    assert_int_equal(moves, 0);
}


Проверяет, что bubbleSort оставляет массив с одним элементом без изменений, с 0 операциями.

// Тест для bubbleSort с уже отсортированным массивом
void test_sorted(void **state) {
    // Создаем отсортированный массив: 1, 2, 3, 4, 5
    int nums[] = {1, 2, 3, 4, 5};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив остался отсортированным
    assert_true(is_sorted(nums, 5));
    // Проверяем, что было 10 сравнений (для 5 чисел: 5*4/2)
    assert_int_equal(comps, 10);
    // Проверяем, что перемещений не было (массив уже отсортирован)
    assert_int_equal(moves, 0);
}


Проверяет, что bubbleSort сохраняет отсортированный массив, с 10 сравнениями и 0 перемещениями.

// Тест для bubbleSort с массивом в обратном порядке
void test_reverse(void **state) {
    // Создаем массив в обратном порядке: 5, 4, 3, 2, 1
    int nums[] = {5, 4, 3, 2, 1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив теперь отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что было 10 сравнений
    assert_int_equal(comps, 10);
    // Проверяем, что было 30 перемещений (3 перемещения на обмен, 10 обменов)
    assert_int_equal(moves, 30);
}


Проверяет, что bubbleSort правильно сортирует массив в обратном порядке, с 10 сравнениями и 30 перемещениями.

// Тест для bubbleSort с массивом в случайном порядке
void test_random(void **state) {
    // Создаем массив с числами в случайном порядке: 3, 1, 4, 5, 2
    int nums[] = {3, 1, 4, 5, 2};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что первое число — 1 (самое маленькое)
    assert_int_equal(nums[0], 1);
    // Проверяем, что последнее число — 5 (самое большое)
    assert_int_equal(nums[4], 5);
}


Проверяет, что bubbleSort сортирует массив в случайном порядке.

// Тест для bubbleSort с массивом, где есть одинаковые числа
void test_same_nums(void **state) {
    // Создаем массив с повторяющимися числами: 3, 1, 3, 2, 1
    int nums[] = {3, 1, 3, 2, 1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что первое число — 1
    assert_int_equal(nums[0], 1);
    // Проверяем, что второе число — 1 (повторение)
    assert_int_equal(nums[1], 1);
    // Проверяем, что последнее число — 3
    assert_int_equal(nums[4], 3);
}


Проверяет, что bubbleSort корректно обрабатывает массив с повторами.

// Тест для make_down_nums с пустым массивом
void test_down_empty(void **state) {
    // Создаем маленький массив, чтобы не было ошибок
    int nums[1] = {0};
    // Вызываем make_down_nums с размером 0 (ничего не должно произойти)
    make_down_nums(nums, 0);
}


Проверяет, что make_down_nums с размером 0 не вызывает ошибок.

// Тест для make_down_nums с одним числом
void test_down_one(void **state) {
    // Создаем массив с одним числом, ставим 0
    int nums[] = {0};
    // Вызываем make_down_nums, чтобы заполнить
    make_down_nums(nums, 1);
    // Проверяем, что число стало 1 (для размера 1 это просто 1)
    assert_int_equal(nums[0], 1);
}


Проверяет, что make_down_nums с одним элементом создаёт [1].

// Тест для make_down_nums с пятью числами
void test_down_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Вызываем make_down_nums, чтобы заполнить числами 5, 4, 3, 2, 1
    make_down_nums(nums, 5);
    // Проверяем, что первое число — 5
    assert_int_equal(nums[0], 5);
    // Проверяем, что последнее число — 1
    assert_int_equal(nums[4], 1);
}


Проверяет, что make_down_nums с пятью элементами создаёт [5, 4, 3, 2, 1].

// Тест для make_up_nums с пустым массивом
void test_up_empty(void **state) {
    // Создаем маленький массив
    int nums[1] = {0};
    // Вызываем make_up_nums с размером 0 (ничего не делаем)
    make_up_nums(nums, 0);
}


Проверяет, что make_up_nums с размером 0 не вызывает ошибок.

// Тест для make_up_nums с одним числом
void test_up_one(void **state) {
    // Создаем массив с одним нулем
    int nums[] = {0};
    // Вызываем make_up_nums, чтобы заполнить
    make_up_nums(nums, 1);
    // Проверяем, что число стало 1
    assert_int_equal(nums[0], 1);
}


Проверяет, что make_up_nums с одним элементом создаёт [1].

// Тест для make_up_nums с пятью числами
void test_up_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Вызываем make_up_nums, чтобы заполнить числами 1, 2, 3, 4, 5
    make_up_nums(nums, 5);
    // Проверяем, что первое число — 1
    assert_int_equal(nums[0], 1);
    // Проверяем, что последнее число — 5
    assert_int_equal(nums[4], 5);
}


Проверяет, что make_up_nums с пятью элементами создаёт [1, 2, 3, 4, 5].

// Тест для make_random_nums с пустым массивом
void test_random_empty(void **state) {
    // Создаем маленький массив
    int nums[1] = {0};
    // Вызываем make_random_nums с размером 0 (ничего не делаем)
    make_random_nums(nums, 0);
}


Проверяет, что make_random_nums с размером 0 не вызывает ошибок.

// Тест для make_random_nums с одним числом
void test_random_one(void **state) {
    // Создаем массив с одним нулем
    int nums[] = {0};
    // Устанавливаем начальное число для случайных чисел, чтобы результаты были одинаковыми
    srand(42);
    // Вызываем make_random_nums, чтобы заполнить одним случайным числом
    make_random_nums(nums, 1);
    // Проверяем, что число от 0 до 99
    assert_in_range(nums[0], 0, 99);
}


Проверяет, что make_random_nums с одним элементом создаёт число от 0 до 99.

// Тест для make_random_nums с пятью числами
void test_random_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Устанавливаем начальное число для случайных чисел
    srand(42);
    // Вызываем make_random_nums, чтобы заполнить пятью случайными числами
    make_random_nums(nums, 5);
    // Проходим по массиву
    for (int i = 0; i < 5; i++) {
        // Проверяем, что каждое число от 0 до 99
        assert_in_range(nums[i], 0, 99);
    }
}


Проверяет, что make_random_nums с пятью элементами создаёт пять чисел от 0 до 99.

// Главная функция, которая запускает все тесты
int main(void) {
    // Создаем список всех тестов
    const struct CMUnitTest tests[] = {
        // Добавляем каждый тест в список
        cmocka_unit_test(test_empty),
        cmocka_unit_test(test_one_num),
        cmocka_unit_test(test_sorted),
        cmocka_unit_test(test_reverse),
        cmocka_unit_test(test_random),
        cmocka_unit_test(test_same_nums),
        cmocka_unit_test(test_down_empty),
        cmocka_unit_test(test_down_one),
        cmocka_unit_test(test_down_five),
        cmocka_unit_test(test_up_empty),
        cmocka_unit_test(test_up_one),
        cmocka_unit_test(test_up_five),
        cmocka_unit_test(test_random_empty),
        cmocka_unit_test(test_random_one),
        cmocka_unit_test(test_random_five),
    };
    // Запускаем все тесты и возвращаем результат (0, если всё прошло)
    return cmocka_run_group_tests(tests, NULL, NULL);
}


Определяет функцию main, которая запускает все тесты с помощью CMocka.

CMakeLists.txt
Этот файл настраивает процесс сборки с использованием CMake. Он указывает компилятору, как собрать программу и запустить тесты.
Построчное объяснение:
cmake_minimum_required(VERSION 3.10)


Указывает, что требуется CMake версии 3.10 или выше для сборки проекта.

project(SortStuff)


Задаёт название проекта «SortStuff» для организации.

enable_testing()


Включает функции тестирования, позволяя запускать модульные тесты с CMake.

set(CMAKE_C_STANDARD 99)


Устанавливает стандарт языка C на C99, чтобы код соответствовал правилам 1999 года.

find_package(CMocka REQUIRED)


Ищет библиотеку CMocka, необходимую для тестирования. Если не найдена, выдаёт ошибку.

include_directories(${CMOCKA_INCLUDE_DIR})


Указывает компилятору, где искать заголовочные файлы CMocka (например, cmocka.h).

include_directories(${CMAKE_SOURCE_DIR})


Указывает компилятору искать наши заголовочные файлы (например, sort.h) в главной папке проекта.

set(FILES sort.c)


Определяет переменную FILES, содержащую sort.c, исходный файл для функций сортировки.

add_library(sort_stuff STATIC ${FILES})


Создаёт статическую библиотеку sort_stuff из sort.c, объединяя функции сортировки для повторного использования.

add_executable(test_it test_sort.c)


Создаёт исполняемый файл test_it из test_sort.c, который будет запускать тесты.

target_link_libraries(test_it sort_stuff ${CMOCKA_LIBRARIES})


Связывает test_it с библиотекой sort_stuff и CMocka, чтобы он мог использовать оба.

add_test(NAME MyTests COMMAND test_it)


Определяет тест MyTests, который запускает test_it.

add_custom_target(run_it


Создаёт пользовательскую команду run_it для запуска тестов с подробным выводом.

    COMMAND ${CMAKE_CTEST_COMMAND} -V


Указывает, что run_it запускает ctest с опцией -V для подробного вывода результатов тестов.

    DEPENDS test_it


Гарантирует, что test_it собран перед запуском тестов.

)


Закрывает определение пользовательской команды.

Как собрать и запустить
Чтобы скомпилировать и запустить проект, выполните следующие шаги (предполагается, что у вас установлены CMake, компилятор C и CMocka):

Клонируйте репозиторий:
git clone <ваш-URL-репозитория>
cd <ваша-папка-репозитория>


Создайте папку для сборки:
mkdir build
cd build


Запустите CMake:
cmake ..

Это создаёт файлы сборки на основе CMakeLists.txt.

Соберите проект:
make

Это компилирует sort.c в библиотеку, test_sort.c в исполняемый файл и связывает их.

Запустите тесты:
make run_it

Это запускает все тесты и показывает подробный вывод. Если все тесты пройдены, вы увидите сообщение об успехе.


Зависимости:

CMake (версия 3.10 или выше)
Компилятор C (например, gcc)
CMocka (установите командой sudo apt-get install libcmocka-dev на Ubuntu или эквивалентной)

Тестовые случаи
Файл test_sort.c включает 15 модульных тестов для проверки кода. Вот что проверяет каждый тест:
Тесты для пузырьковой сортировки

test_empty: Проверяет, что bubbleSort обрабатывает пустой массив (NULL, размер 0) без ошибок, с 0 сравнениями/перемещениями.
test_one_num: Убеждается, что bubbleSort оставляет массив с одним элементом без изменений, с 0 операциями.
test_sorted: Проверяет, что bubbleSort сохраняет отсортированный массив (1, 2, 3, 4, 5), с 10 сравнениями и 0 перемещениями.
test_reverse: Убеждается, что bubbleSort сортирует массив в обратном порядке (5, 4, 3, 2, 1), с 10 сравнениями и 30 перемещениями.
test_random: Проверяет, что bubbleSort сортирует массив в случайном порядке (3, 1, 4, 5, 2), проверяя первый и последний элементы.
test_same_nums: Убеждается, что bubbleSort корректно обрабатывает повторы (3, 1, 3, 2, 1), сортируя в (1, 1, 2, 3, 3).

Тесты для генерации массивов

test_down_empty: Проверяет, что make_down_nums с размером 0 не вызывает ошибок.
test_down_one: Убеждается, что make_down_nums с размером 1 создаёт [1].
test_down_five: Проверяет, что make_down_nums с размером 5 создаёт [5, 4, 3, 2, 1].
test_up_empty: Проверяет, что make_up_nums с размером 0 не вызывает ошибок.
test_up_one: Убеждается, что make_up_nums с размером 1 создаёт [1].
test_up_five: Проверяет, что make_up_nums с размером 5 создаёт [1, 2, 3, 4, 5].
test_random_empty: Проверяет, что make_random_nums с размером 0 не вызывает ошибок.
test_random_one: Убеждается, что make_random_nums с размером 1 создаёт число от 0 до 99.
test_random_five: Проверяет, что make_random_nums с размером 5 создаёт пять чисел от 0 до 99.

Содержимое файлов
Ниже приведено полное содержимое каждого файла для справки.
sort.h
#ifndef SORT_H
#define SORT_H

void bubbleSort(int nums[], int count, int *comps, int *moves);
void make_down_nums(int nums[], int count);
void make_random_nums(int nums[], int count);
void make_up_nums(int nums[], int count);

#endif

sort.c
#include <stdio.h>
#include <stdlib.h>
#include "sort.h"

void bubbleSort(int nums[], int count, int *comps, int *moves) {
    *comps = 0;
    *moves = 0;
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - i - 1; j++) {
            (*comps)++;
            if (nums[j] > nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
                (*moves) += 3;
            }
        }
    }
}

void make_down_nums(int nums[], int count) {
    for (int i = 0; i < count; i++) {
        nums[i] = count - i;
    }
}

void make_random_nums(int nums[], int count) {
    for (int i = 0; i < count; i++) {
        nums[i] = rand() % 100;
    }
}

void make_up_nums(int nums[], int count) {
    for (int i = 0; i < count; i++) {
        nums[i] = i + 1;
    }
}

test_sort.c
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>
#include <stdlib.h>
#include "sort.h"

// Проверяет, отсортирован ли массив (числа идут по порядку от меньшего к большему)
int is_sorted(int nums[], int count) {
    // Проходим по массиву, но не до конца, чтобы сравнить с следующим числом
    for (int i = 0; i < count - 1; i++) {
        // Если текущее число больше следующего, массив не отсортирован
        if (nums[i] > nums[i + 1]) {
            // Возвращаем 0 (значит "не отсортирован")
            return 0;
        }
    }
    // Если дошли сюда, массив отсортирован, возвращаем 1 (значит "да")
    return 1;
}

// Тест для bubbleSort с пустым массивом
void test_empty(void **state) {
    // Создаем указатель на массив, но он пустой (NULL)
    int *nums = NULL;
    // Создаем счетчики для сравнений и перемещений, ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort с пустым массивом и размером 0
    bubbleSort(nums, 0, &comps, &moves);
    // Проверяем, что сравнений не было (должно быть 0)
    assert_int_equal(comps, 0);
    // Проверяем, что перемещений не было (должно быть 0)
    assert_int_equal(moves, 0);
}

// Тест для bubbleSort с массивом из одного числа
void test_one_num(void **state) {
    // Создаем массив с одним числом: 1
    int nums[] = {1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort для массива с одним числом
    bubbleSort(nums, 1, &comps, &moves);
    // Проверяем, что число осталось 1 (не должно измениться)
    assert_int_equal(nums[0], 1);
    // Проверяем, что сравнений не было
    assert_int_equal(comps, 0);
    // Проверяем, что перемещений не было
    assert_int_equal(moves, 0);
}

// Тест для bubbleSort с уже отсортированным массивом
void test_sorted(void **state) {
    // Создаем отсортированный массив: 1, 2, 3, 4, 5
    int nums[] = {1, 2, 3, 4, 5};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив остался отсортированным
    assert_true(is_sorted(nums, 5));
    // Проверяем, что было 10 сравнений (для 5 чисел: 5*4/2)
    assert_int_equal(comps, 10);
    // Проверяем, что перемещений не было (массив уже отсортирован)
    assert_int_equal(moves, 0);
}

// Тест для bubbleSort с массивом в обратном порядке
void test_reverse(void **state) {
    // Создаем массив в обратном порядке: 5, 4, 3, 2, 1
    int nums[] = {5, 4, 3, 2, 1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив теперь отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что было 10 сравнений
    assert_int_equal(comps, 10);
    // Проверяем, что было 30 перемещений (3 перемещения на обмен, 10 обменов)
    assert_int_equal(moves, 30);
}

// Тест для bubbleSort с массивом в случайном порядке
void test_random(void **state) {
    // Создаем массив с числами в случайном порядке: 3, 1, 4, 5, 2
    int nums[] = {3, 1, 4, 5, 2};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что первое число — 1 (самое маленькое)
    assert_int_equal(nums[0], 1);
    // Проверяем, что последнее число — 5 (самое большое)
    assert_int_equal(nums[4], 5);
}

// Тест для bubbleSort с массивом, где есть одинаковые числа
void test_same_nums(void **state) {
    // Создаем массив с повторяющимися числами: 3, 1, 3, 2, 1
    int nums[] = {3, 1, 3, 2, 1};
    // Создаем счетчики и ставим 0
    int comps = 0, moves = 0;
    // Вызываем bubbleSort, чтобы отсортировать
    bubbleSort(nums, 5, &comps, &moves);
    // Проверяем, что массив отсортирован
    assert_true(is_sorted(nums, 5));
    // Проверяем, что первое число — 1
    assert_int_equal(nums[0], 1);
    // Проверяем, что второе число — 1 (повторение)
    assert_int_equal(nums[1], 1);
    // Проверяем, что последнее число — 3
    assert_int_equal(nums[4], 3);
}

// Тест для make_down_nums с пустым массивом
void test_down_empty(void **state) {
    // Создаем маленький массив, чтобы не было ошибок
    int nums[1] = {0};
    // Вызываем make_down_nums с размером 0 (ничего не должно произойти)
    make_down_nums(nums, 0);
}

// Тест для make_down_nums с одним числом
void test_down_one(void **state) {
    // Создаем массив с одним числом, ставим 0
    int nums[] = {0};
    // Вызываем make_down_nums, чтобы заполнить
    make_down_nums(nums, 1);
    // Проверяем, что число стало 1 (для размера 1 это просто 1)
    assert_int_equal(nums[0], 1);
}

// Тест для make_down_nums с пятью числами
void test_down_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Вызываем make_down_nums, чтобы заполнить числами 5, 4, 3, 2, 1
    make_down_nums(nums, 5);
    // Проверяем, что первое число — 5
    assert_int_equal(nums[0], 5);
    // Проверяем, что последнее число — 1
    assert_int_equal(nums[4], 1);
}

// Тест для make_up_nums с пустым массивом
void test_up_empty(void **state) {
    // Создаем маленький массив
    int nums[1] = {0};
    // Вызываем make_up_nums с размером 0 (ничего не делаем)
    make_up_nums(nums, 0);
}

// Тест для make_up_nums с одним числом
void test_up_one(void **state) {
    // Создаем массив с одним нулем
    int nums[] = {0};
    // Вызываем make_up_nums, чтобы заполнить
    make_up_nums(nums, 1);
    // Проверяем, что число стало 1
    assert_int_equal(nums[0], 1);
}

// Тест для make_up_nums с пятью числами
void test_up_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Вызываем make_up_nums, чтобы заполнить числами 1, 2, 3, 4, 5
    make_up_nums(nums, 5);
    // Проверяем, что первое число — 1
    assert_int_equal(nums[0], 1);
    // Проверяем, что последнее число — 5
    assert_int_equal(nums[4], 5);
}

// Тест для make_random_nums с пустым массивом
void test_random_empty(void **state) {
    // Создаем маленький массив
    int nums[1] = {0};
    // Вызываем make_random_nums с размером 0 (ничего не делаем)
    make_random_nums(nums, 0);
}

// Тест для make_random_nums с одним числом
void test_random_one(void **state) {
    // Создаем массив с одним нулем
    int nums[] = {0};
    // Устанавливаем начальное число для случайных чисел, чтобы результаты были одинаковыми
    srand(42);
    // Вызываем make_random_nums, чтобы заполнить одним случайным числом
    make_random_nums(nums, 1);
    // Проверяем, что число от 0 до 99
    assert_in_range(nums[0], 0, 99);
}

// Тест для make_random_nums с пятью числами
void test_random_five(void **state) {
    // Создаем массив из пяти нулей
    int nums[] = {0, 0, 0, 0, 0};
    // Устанавливаем начальное число для случайных чисел
    srand(42);
    // Вызываем make_random_nums, чтобы заполнить пятью случайными числами
    make_random_nums(nums, 5);
    // Проходим по массиву
    for (int i = 0; i < 5; i++) {
        // Проверяем, что каждое число от 0 до 99
        assert_in_range(nums[i], 0, 99);
    }
}

// Главная функция, которая запускает все тесты
int main(void) {
    // Создаем список всех тестов
    const struct CMUnitTest tests[] = {
        // Добавляем каждый тест в список
        cmocka_unit_test(test_empty),
        cmocka_unit_test(test_one_num),
        cmocka_unit_test(test_sorted),
        cmocka_unit_test(test_reverse),
        cmocka_unit_test(test_random),
        cmocka_unit_test(test_same_nums),
        cmocka_unit_test(test_down_empty),
        cmocka_unit_test(test_down_one),
        cmocka_unit_test(test_down_five),
        cmocka_unit_test(test_up_empty),
        cmocka_unit_test(test_up_one),
        cmocka_unit_test(test_up_five),
        cmocka_unit_test(test_random_empty),
        cmocka_unit_test(test_random_one),
        cmocka_unit_test(test_random_five),
    };
    // Запускаем все тесты и возвращаем результат (0, если всё прошло)
    return cmocka_run_group_tests(tests, NULL, NULL);
}

CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(SortStuff)

enable_testing()

set(CMAKE_C_STANDARD 99)

find_package(CMocka REQUIRED)
include_directories(${CMOCKA_INCLUDE_DIR})
include_directories(${CMAKE_SOURCE_DIR})

set(FILES sort.c)

add_library(sort_stuff STATIC ${FILES})

add_executable(test_it test_sort.c)
target_link_libraries(test_it sort_stuff ${CMOCKA_LIBRARIES})

add_test(NAME MyTests COMMAND test_it)

add_custom_target(run_it
    COMMAND ${CMAKE_CTEST_COMMAND} -V
    DEPENDS test_it
)


